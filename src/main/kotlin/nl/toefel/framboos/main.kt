/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package nl.toefel.framboos


import nl.toefel.framboos.API.PRIVATE
import nl.toefel.framboos.dto.Result.CORRECT
import nl.toefel.framboos.dto.Result.DOES_NOT_COMPUTE
import nl.toefel.framboos.dto.Result.GAME_ENDED
import nl.toefel.framboos.dto.Result.INCORRECT_LENGTH
import nl.toefel.framboos.dto.Result.INCORRECT_ROUND
import nl.toefel.framboos.dto.Result.OUT_OF_BOUNDS
import nl.toefel.framboos.dto.Result.TOO_HIGH
import nl.toefel.framboos.dto.Result.TOO_LOW
import nl.toefel.framboos.dto.SolutionRequest
import nl.toefel.framboos.dto.SolutionResponse
import java.lang.IllegalStateException
import java.time.ZonedDateTime

data class Try(val score: Long, val operators: List<String>) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Try

        if (operators != other.operators) return false

        return true
    }

    override fun hashCode(): Int {
        return operators.hashCode()
    }
}

data class State(
    var upperBound: Long = Long.MAX_VALUE,
    var lowerBound: Long = Long.MIN_VALUE,
    var options: MutableList<Try> = mutableListOf(),
    var previousTries: MutableList<Int> = mutableListOf(),
) {
    fun reset() {
        upperBound = Long.MAX_VALUE
        lowerBound = Long.MIN_VALUE
        options = mutableListOf()
        previousTries = mutableListOf()
    }
}

fun main() {
    val http = Client()
    http.configureUser("rekenwonder", "wonder")

    http.setEndTime(PRIVATE, ZonedDateTime.now().plusMinutes(15))
    http.reset(PRIVATE)

    var request = SolutionRequest(listOf(), 0)
    var currentResponse = http.postSolution(PRIVATE, request)
    var state = State()

    while (true) {
        request = when (currentResponse.result) {
            CORRECT -> {
                state.reset();
                SolutionRequest(listOf(), currentResponse.currentRound)
            }
            TOO_LOW -> calculateHigher(currentResponse, state, request)
            TOO_HIGH -> calculateLower(currentResponse, state, request)
            INCORRECT_ROUND -> {
                state.reset()
                SolutionRequest(listOf(), currentResponse.currentRound)
            }
            INCORRECT_LENGTH -> {
                state.reset()
                val options = Bruteforcer.computeCombinations(currentResponse.problem.size - 1)
                state.options = options.mapNotNull { toOption(it, currentResponse.problem) }.sortedBy { it.score }.toMutableList()
                state.previousTries.add(state.options.size - 1)
                SolutionRequest(state.options[state.previousTries.last()].operators, currentResponse.currentRound)
            }
            OUT_OF_BOUNDS -> {
                state.reset()
                SolutionRequest(listOf(), 0)
            }
            DOES_NOT_COMPUTE -> {
                state.reset()
                SolutionRequest(listOf(), currentResponse.currentRound)
            }
            GAME_ENDED -> return
        }
        currentResponse = http.postSolution(PRIVATE, request)
    }
}

fun toOption(operators: List<String>, problem: List<Long>): Try? {
    return try {
        Try(solve(problem, operators), operators)
    } catch (ex: Exception) {
        println(ex)
        null
    }
}

fun calculateLower(currentResponse: SolutionResponse, state: State, previousRequest: SolutionRequest): SolutionRequest {
    val last = state.previousTries.last()
    if (last == 0) throw IllegalStateException("HELP, no more options")
    state.previousTries.add(last - 1)
    return SolutionRequest(state.options[state.previousTries.last()].operators, currentResponse.currentRound)
}

fun calculateHigher(currentResponse: SolutionResponse, state: State, previousRequest: SolutionRequest): SolutionRequest {
    val last = state.previousTries.last()
    if (last >= state.options.size) throw IllegalStateException("HELP, no more options")
    state.previousTries.add(last + 1)
    return SolutionRequest(state.options[state.previousTries.last()].operators, currentResponse.currentRound)
}

fun solve(problem: List<Long>, operands: List<String>) : Long {
    val solution = problem.toMutableList()
    val operatorsLeft = operands.toMutableList()
    
    while(true) {
        if (operatorsLeft.isEmpty()) return solution.first()
        val timesIdx = operatorsLeft.indexOf("*")
        val divIdx = operatorsLeft.indexOf("/")
        if (timesIdx >= 0 && timesIdx > divIdx) {
            solution[timesIdx] = solution[timesIdx] * solution[timesIdx + 1]
            solution.removeAt(timesIdx + 1)
            operatorsLeft.removeAt(timesIdx)
            continue
        } else if (divIdx >= 0 ) {
            solution[divIdx] = solution[divIdx] / solution[divIdx + 1]
            solution.removeAt(divIdx + 1)
            operatorsLeft.removeAt(divIdx)
            continue
        }

        val plusIdx = operatorsLeft.indexOf("+")
        val minIdx = operatorsLeft.indexOf("-")
        if (plusIdx >= 0 && plusIdx > minIdx) {
            solution[plusIdx] = solution[plusIdx] + solution[plusIdx + 1]
            solution.removeAt(plusIdx + 1)
            operatorsLeft.removeAt(plusIdx)
            continue
        } else if (minIdx >= 0 ) {
            solution[minIdx] = solution[minIdx] - solution[minIdx + 1]
            solution.removeAt(minIdx + 1)
            operatorsLeft.removeAt(minIdx)
            continue
        }
    }
}